// Copyright Â©2017 The gonum Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

// +build go1.7

package f32

import (
	"fmt"
	"math"
	"testing"

	"gonum.org/v1/gonum/blas/testblas"
)

var gerTests = []struct {
	name string
	a    []float32
	m    uintptr
	n    uintptr
	x    []float32
	y    []float32

	trueAns []float32
}{
	{
		name:    "Unit",
		m:       1,
		n:       1,
		a:       []float32{10},
		x:       []float32{2},
		y:       []float32{4.4},
		trueAns: []float32{18.8},
	},
	{
		name: "M gt N",
		m:    5,
		n:    3,
		a: []float32{
			1.3, 2.4, 3.5,
			2.6, 2.8, 3.3,
			-1.3, -4.3, -9.7,
			8, 9, -10,
			-12, -14, -6,
		},
		x:       []float32{-2, -3, 0, 1, 2},
		y:       []float32{-1.1, 5, 0},
		trueAns: []float32{3.5, -7.6, 3.5, 5.9, -12.2, 3.3, -1.3, -4.3, -9.7, 6.9, 14, -10, -14.2, -4, -6},
	},
	{
		name: "M eq N",
		m:    3,
		n:    3,
		a: []float32{
			1.3, 2.4, 3.5,
			2.6, 2.8, 3.3,
			-1.3, -4.3, -9.7,
		},
		x:       []float32{-2, -3, 0},
		y:       []float32{-1.1, 5, 0},
		trueAns: []float32{3.5, -7.6, 3.5, 5.9, -12.2, 3.3, -1.3, -4.3, -9.7},
	},
	{
		name: "M lt N",
		m:    3,
		n:    6,
		a: []float32{
			1.3, 2.4, 3.5, 4.8, 1.11, -9,
			2.6, 2.8, 3.3, -3.4, 6.2, -8.7,
			-1.3, -4.3, -9.7, -3.1, 8.9, 8.9,
		},
		x:       []float32{-2, -3, 0},
		y:       []float32{-1.1, 5, 0, 9, 19, 22},
		trueAns: []float32{3.5, -7.6, 3.5, -13.2, -36.89, -53, 5.9, -12.2, 3.3, -30.4, -50.8, -74.7, -1.3, -4.3, -9.7, -3.1, 8.9, 8.9},
	},
	{
		name: "M gt N",
		m:    5,
		n:    3,
		a: []float32{
			1.3, 2.4, 3.5,
			2.6, 2.8, 3.3,
			-1.3, -4.3, -9.7,
			8, 9, -10,
			-12, -14, -6,
		},
		x:       []float32{-2, 0, 2, 0, 7},
		y:       []float32{-1.1, 8, 7},
		trueAns: []float32{3.5, -13.6, -10.5, 2.6, 2.8, 3.3, -3.5, 11.7, 4.3, 8, 9, -10, -19.700000000000003, 42, 43},
	},
	{
		name: "M eq N",
		m:    3,
		n:    3,
		a: []float32{
			1.3, 2.4, 3.5,
			2.6, 2.8, 3.3,
			-1.3, -4.3, -9.7,
		},
		x:       []float32{-2, 7, 12, -11},
		y:       []float32{-1.1, 0, 6},
		trueAns: []float32{3.5, 2.4, -8.5, -5.1, 2.8, 45.3, -14.5, -4.3, 62.3},
	},
	{
		name:    "M lt N",
		m:       3,
		n:       6,
		a:       []float32{1.3, 2.4, 3.5, 4.8, 1.11, -9, 2.6, 2.8, 3.3, -3.4, 6.2, -8.7, -1.3, -4.3, -9.7, -3.1, 8.9, 8.9},
		x:       []float32{-2, 0, 9, -3},
		y:       []float32{-1.1, 0, 19, 11, -9.22, 7},
		trueAns: []float32{3.5, 2.4, -34.5, -17.2, 19.55, -23, 2.6, 2.8, 3.3, -3.4, 6.2, -8.7, -11.2, -4.3, 161.3, 95.9, -74.08, 71.9},
	},
	{
		name:    "Y NaN element",
		m:       1,
		n:       1,
		a:       []float32{1.3},
		x:       []float32{1.3},
		y:       []float32{float32(math.NaN())},
		trueAns: []float32{float32(math.NaN())},
	},
	{
		name: "M eq N large",
		m:    7,
		n:    7,
		x:    []float32{6.2, -5, 2.68, 3.4, -3.5, -4.2, 19.9},
		y:    []float32{1.5, 21.7, -2.7, -11.9, 8.1, 3.1, 17},
		a: []float32{
			-20.5, 17.1, -8.4, -23.8, 3.9, 7.7, 6.25,
			2.9, -0.29, 25.6, -9.4, 36.5, 9.7, 2.3,
			4.1, -34.1, 10.3, 4.5, -42.05, 9.4, 4,
			19.2, 9.8, -32.7, 4.1, 4.4, -22.5, -7.8,
			3.6, -24.5, 21.7, 8.6, -13.82, 38.05, -2.29,
			39.4, -40.5, 7.9, -2.5, -7.7, 18.1, -25.5,
			-18.5, 43.2, 2.1, 30.1, 3.02, -31.1, -7.6,
		},
		trueAns: []float32{
			-11.200001, 151.64, -25.14, -97.58, 54.120003, 26.919998, 111.649994,
			-4.6, -108.79, 39.1, 50.1, -4, -5.8, -82.7,
			8.12, 24.056004, 3.0639997, -27.392, -20.341997, 17.708, 49.56,
			24.300001, 83.58001, -41.88, -36.36, 31.940002, -11.96, 50.000004,
			-1.6500001, -100.450005, 31.150002, 50.25, -42.170002, 27.2, -61.79,
			33.100002, -131.64, 19.24, 47.479996, -41.72, 5.080002, -96.899994,
			11.349998, 475.03003, -51.63, -206.70998, 164.21, 30.589998, 330.69998,
		},
	},
	{
		name: "M eq N large",
		m:    7,
		n:    7,
		x:    []float32{6.2, -5, 88.68, 43.4, -30.5, -40.2, 19.9},
		y:    []float32{1.5, 21.7, -28.7, -11.9, 18.1, 3.1, 21},
		a: []float32{
			-20.5, 17.1, -8.4, -23.8, 3.9, 7.7, 6.25,
			2.9, -0.29, 25.6, -9.4, 36.5, 9.7, 2.3,
			4.1, -34.1, 10.3, 4.5, -42.05, 9.4, 4,
			19.2, 9.8, -32.7, 4.1, 4.4, -22.5, -7.8,
			3.6, -24.5, 21.7, 8.6, -13.82, 38.05, -2.29,
			39.4, -40.5, 7.9, -2.5, -7.7, 18.1, -25.5,
			-18.5, 43.2, 2.1, 30.1, 3.02, -31.1, -7.6,
		},
		trueAns: []float32{
			-11.200001, 151.64, -186.34, -97.58, 116.12, 26.919998, 136.45,
			-4.6, -108.79, 169.1, 50.1, -54, -5.8, -102.7,
			137.12001, 1890.2561, -2534.816, -1050.792, 1563.058, 284.30798, 1866.28,
			84.3, 951.5801, -1278.28, -512.36005, 789.94006, 112.03999, 903.60004,
			-42.15, -686.35004, 897.05005, 371.55, -565.87, -56.499996, -642.79,
			-20.900002, -912.84, 1161.6401, 475.88, -735.32007, -106.52, -869.7,
			11.349998, 475.03003, -569.03, -206.70998, 363.21, 30.589998, 410.3,
		},
	},
	{
		name: "M eq N xlarge",
		m:    15,
		n:    15,
		x:    []float32{6.2, -5, 88.68, 43.4, -30.5, -40.2, 19.9, 3, 19.9, -40.2, -30.5, 43.4, 88.68, -5, 6.2},
		y:    []float32{1.5, 21.7, -28.7, -11.9, 18.1, 3.1, 21, 8, 21, 3.1, 18.1, -11.9, -28.7, 21.7, 1.5},
		a: []float32{
			-20.5, 17.1, -8.4, -23.8, 3.9, 7.7, 6.25, 2.9, -0.29, 25.6, -9.4, 36.5, 9.7, 2.3, 4.1,
			-34.1, 10.3, 4.5, -42.05, 9.4, 4, 19.2, 9.8, -32.7, 4.1, 4.4, -22.5, -7.8, 3.6, -24.5,
			21.7, 8.6, -13.82, 3.05, -2.29, 39.4, -40, 7.9, -2.5, -7.7, 18.1, -25.5, -18.5, 43.2, 2.1,
			-20.5, 17.1, -8.4, -23.8, 3.9, 7.7, 6.25, 2.9, -0.29, 25.6, -9.4, 36.5, 9.7, 2.3, 4.1,
			-34.1, 10.3, 4.5, -42.05, 9.4, 4, 19.2, 9.8, -32.7, 4.1, 4.4, -22.5, -7.8, 3.6, -24.5,
			21.7, 8.6, -13.82, 3.05, -2.29, 39.4, -40, 7.9, -2.5, -7.7, 18.1, -25.5, -18.5, 43.2, 2.1,
			21.7, 8.6, -13.82, 3.05, -2.29, 39.4, -40, 7.9, -2.5, -7.7, 18.1, -25.5, -18.5, 43.2, 2.1,
			-34.1, 10.3, 4.5, -42.05, 9.4, 4, 19.2, 9.8, -32.7, 4.1, 4.4, -22.5, -7.8, 3.6, -24.5,
			-20.5, 17.1, -8.4, -23.8, 3.9, 7.7, 6.25, 2.9, -0.29, 25.6, -9.4, 36.5, 9.7, 2.3, 4.1,
			21.7, 8.6, -13.82, 3.05, -2.29, 39.4, -40, 7.9, -2.5, -7.7, 18.1, -25.5, -18.5, 43.2, 2.1,
			-34.1, 10.3, 4.5, -42.05, 9.4, 4, 19.2, 9.8, -32.7, 4.1, 4.4, -22.5, -7.8, 3.6, -24.5,
			-20.5, 17.1, -8.4, -23.8, 3.9, 7.7, 6.25, 2.9, -0.29, 25.6, -9.4, 36.5, 9.7, 2.3, 4.1,
			-20.5, 17.1, -8.4, -23.8, 3.9, 7.7, 6.25, 2.9, -0.29, 25.6, -9.4, 36.5, 9.7, 2.3, 4.1,
			21.7, 8.6, -13.82, 3.05, -2.29, 39.4, -40, 7.9, -2.5, -7.7, 18.1, -25.5, -18.5, 43.2, 2.1,
			-34.1, 10.3, 4.5, -42.05, 9.4, 4, 19.2, 9.8, -32.7, 4.1, 4.4, -22.5, -7.8, 3.6, -24.5,
		},
		trueAns: []float32{
			-11.200001, 151.64, -186.34, -97.58, 116.12, 26.919998, 136.45, 52.5, 129.91, 44.82, 102.82, -37.28, -168.24, 136.84, 13.4,
			-41.6, -98.2, 148, 17.45, -81.1, -11.5, -85.8, -30.2, -137.7, -11.4, -86.1, 37, 135.7, -104.9, -32,
			154.72, 1932.956, -2558.936, -1052.242, 1602.818, 314.30798, 1822.28, 717.34, 1859.78, 267.20798, 1623.208, -1080.792, -2563.616, 1967.556, 135.12001,
			44.600006, 958.88007, -1253.9801, -540.26, 789.44006, 142.23999, 917.65, 350.1, 911.11005, 160.14, 776.14, -479.96002, -1235.8801, 944.0801, 69.200005,
			-79.85, -651.55005, 879.85004, 320.9, -542.64996, -90.549995, -621.3, -234.2, -673.2, -90.45, -547.64996, 340.44998, 867.55005, -658.25006, -70.25,
			-38.600002, -863.74005, 1139.9202, 481.43, -729.91003, -85.21999, -884.2, -313.7, -846.7, -132.31999, -709.5201, 452.88, 1135.2401, -829.14, -58.200005,
			51.55, 440.43002, -584.95, -233.75998, 357.9, 101.09, 377.9, 167.09999, 415.4, 53.989998, 378.29, -262.31, -589.63, 475.03003, 31.949999,
			-29.599998, 75.40001, -81.600006, -77.75, 63.700005, 13.299999, 82.2, 33.8, 30.3, 13.4, 58.700005, -58.199997, -93.90001, 68.700005, -20,
			9.349998, 448.93002, -579.53, -260.61, 364.09, 69.39, 424.15, 162.09999, 417.61, 87.29, 350.79, -200.30998, -561.43, 434.13, 33.949997,
			-38.600002, -863.74005, 1139.9202, 481.43, -729.91003, -85.21999, -884.2, -313.7, -846.7, -132.31999, -709.5201, 452.88, 1135.2401, -829.14, -58.200005,
			-79.85, -651.55005, 879.85004, 320.9, -542.64996, -90.549995, -621.3, -234.2, -673.2, -90.45, -547.64996, 340.44998, 867.55005, -658.25006, -70.25,
			44.600006, 958.88007, -1253.9801, -540.26, 789.44006, 142.23999, 917.65, 350.1, 911.11005, 160.14, 776.14, -479.96002, -1235.8801, 944.0801, 69.200005,
			112.520004, 1941.456, -2553.5159, -1079.092, 1609.008, 282.608, 1868.53, 712.34, 1861.99, 300.508, 1595.708, -1018.792, -2535.416, 1926.6561, 137.12001,
			14.200001, -99.9, 129.68, 62.55, -92.79, 23.900002, -145, -32.1, -107.5, -23.2, -72.4, 34, 125, -65.3, -5.4,
			-24.8, 144.84, -173.44, -115.83, 121.62, 23.22, 149.4, 59.399998, 97.5, 23.32, 116.62, -96.28, -185.74, 138.14, -15.200001,
		},
	},
}

func TestGer(t *testing.T) {
	// Ger(test.m, test.n, test.alpha, test.x, test.incX, test.y, test.incY, test.a, test.lda)
	const (
		xGdVal, yGdVal, aGdVal = -0.5, 1.5, -1
		gdLn                   = 4
	)

	for _, test := range gerTests {
		var alpha float32 = 1.0
		for _, align := range align2 {
			prefix := fmt.Sprintf("Test %v (%vx%v) (x:%v y:%v a:%v)", test.name, test.m, test.n, align.x, align.y, align.x^align.y)
			xg, yg := guardVector(test.x, xGdVal, align.x+gdLn), guardVector(test.y, yGdVal, align.y+gdLn)
			x, y := xg[align.x+gdLn:len(xg)-(align.x+gdLn)], yg[align.y+gdLn:len(yg)-(align.y+gdLn)]
			ag := guardVector(test.a, aGdVal, align.x^align.y+gdLn)
			a := ag[(align.x^align.y)+gdLn : len(ag)-(align.x^align.y+gdLn)]
			Ger(test.m, test.n, alpha, x, 1, y, 1, a, test.n)
			for i := range test.trueAns {
				if !within(a[i], test.trueAns[i]) {
					t.Errorf(msgVal, prefix, i, a[i], test.trueAns[i])
				}
			}

			if !isValidGuard(xg, xGdVal, gdLn) {
				t.Errorf(msgGuard, prefix, "x", xg[:gdLn], xg[len(xg)-gdLn:])
			}
			if !isValidGuard(yg, yGdVal, gdLn) {
				t.Errorf(msgGuard, prefix, "y", yg[:gdLn], yg[len(yg)-gdLn:])
			}
			if !isValidGuard(ag, aGdVal, gdLn) {
				t.Errorf(msgGuard, prefix, "a", ag[:gdLn], ag[len(ag)-gdLn:])
			}

			if !equalStrided(test.x, x, 1) {
				t.Errorf("%v: modified read-only x argument", prefix)
			}
			if !equalStrided(test.y, y, 1) {
				t.Errorf("%v: modified read-only y argument", prefix)
			}
		}
		alpha = 3.0
		for _, inc := range newIncSet(2, 3, 5) {
			prefix := fmt.Sprintf("Test %v (%vx%v) inc (x:%v y:%v)", test.name, test.m, test.n, inc.x, inc.y)

			xg := guardIncVector(test.x, xGdVal, inc.x, gdLn)
			yg := guardIncVector(test.y, yGdVal, inc.y, gdLn)
			x, y := xg[gdLn:len(xg)-gdLn], yg[gdLn:len(yg)-gdLn]
			ag := guardVector(test.a, aGdVal, gdLn)
			a := ag[gdLn : len(ag)-gdLn]

			Ger(test.m, test.n, alpha, x, uintptr(inc.x), y, uintptr(inc.y), a, test.n)
			for i := range test.trueAns {
				tmp := alpha*test.x[i/int(test.n)]*test.y[i%int(test.n)] + test.a[i]
				if !within(a[i], tmp) {
					t.Errorf(msgVal, prefix, i, a[i], tmp)
				}
			}

			checkValidIncGuard(t, xg, xGdVal, inc.x, gdLn)
			checkValidIncGuard(t, yg, yGdVal, inc.y, gdLn)
			if !isValidGuard(ag, aGdVal, gdLn) {
				t.Errorf(msgGuard, prefix, "a", ag[:gdLn], ag[len(ag)-gdLn:])
			}

			if !equalStrided(test.x, x, inc.x) {
				t.Errorf("%v: modified read-only x argument", prefix)
			}
			if !equalStrided(test.y, y, inc.y) {
				t.Errorf("%v: modified read-only y argument", prefix)
			}
			if t.Failed() {
				t.Log(test.x, "\n", test.y)
			}
		}
	}
}

type sgerWrap struct{}

func (d sgerWrap) Sger(m, n int, alpha float32, x []float32, incX int, y []float32, incY int, a []float32, lda int) {
	Ger(uintptr(m), uintptr(n), alpha, x, uintptr(incX), y, uintptr(incY), a, uintptr(lda))
}

func BenchmarkBlasGer(t *testing.B) {
	for _, dims := range newIncSet(3, 10, 30, 100, 300, 1000, 1e4, 1e5) {
		m, n := dims.x, dims.y
		if m/n >= 100 || n/m >= 100 || (m == 1e5 && n == 1e5) {
			continue
		}
		for _, inc := range newIncSet(1, 2, 3, 4, 10) {
			incX, incY := inc.x, inc.y
			t.Run(fmt.Sprintf("Sger %dx%d (%d %d)", m, n, incX, incY), func(b *testing.B) {
				for i := 0; i < t.N; i++ {
					testblas.SgerBenchmark(b, sgerWrap{}, m, n, incX, incY)
				}
			})
		}
	}
}

func GerOld(m, n uintptr, alpha float32,
	x []float32, incX uintptr,
	y []float32, incY uintptr,
	a []float32, lda uintptr) {

	if incX == 1 && incY == 1 {
		x = x[:m]
		y = y[:n]
		for i, xv := range x {
			AxpyUnitary(alpha*xv, y, a[uintptr(i)*lda:uintptr(i)*lda+n])
		}
		return
	}

	var ky, kx uintptr
	if incY > 0 {
		ky = 0
	} else {
		ky = -(n - 1) * incY
	}
	if incX > 0 {
		kx = 0
	} else {
		kx = -(m - 1) * incX
	}

	ix := kx
	for i := 0; i < int(m); i++ {
		AxpyInc(alpha*x[ix], y, a[uintptr(i)*lda:uintptr(i)*lda+n], uintptr(n), uintptr(incY), 1, uintptr(ky), 0)
		ix += incX
	}
}
